"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MemberAssociation = exports.AssociationType = exports.Enum = exports.Clazz = exports.TypeAlias = exports.Interface = exports.NamedType = exports.HeritageClauseType = void 0;
const path_1 = require("path");
const chalk_1 = __importDefault(require("chalk"));
var HeritageClauseType;
(function (HeritageClauseType) {
    HeritageClauseType[HeritageClauseType["Extends"] = 0] = "Extends";
    HeritageClauseType[HeritageClauseType["Implements"] = 1] = "Implements";
})(HeritageClauseType || (exports.HeritageClauseType = HeritageClauseType = {}));
[];
class NamedType {
    constructor(options) {
        this.name = options.name;
        this.id = options.id;
    }
    getRelativeFilePath(fromFile) {
        const rx = /"(.*)"/;
        const result = rx.exec(this.id);
        if (!result) {
            console.log(chalk_1.default.redBright("Could not compute path to class / interface definition: " + this.id));
            return "";
        }
        const toFile = (0, path_1.resolve)(result[1] + '.ts');
        if (!fromFile) {
            // return the absolute path if no fromFile is given
            return toFile;
        }
        fromFile = (0, path_1.resolve)((0, path_1.dirname)(fromFile));
        let rel = (0, path_1.relative)(fromFile, toFile);
        return rel;
    }
}
exports.NamedType = NamedType;
class Interface extends NamedType {
    constructor(options) {
        super(options);
        this.properties = options.properties;
        this.methods = options.methods;
        this.heritageClauses = options.heritageClauses || [];
    }
}
exports.Interface = Interface;
class TypeAlias extends Interface {
}
exports.TypeAlias = TypeAlias;
class Clazz extends Interface {
}
exports.Clazz = Clazz;
class Enum extends NamedType {
    constructor(options) {
        super(options);
        this.items = [];
        this.items = options.enumItems;
    }
}
exports.Enum = Enum;
var AssociationType;
(function (AssociationType) {
    AssociationType[AssociationType["Association"] = 0] = "Association";
})(AssociationType || (exports.AssociationType = AssociationType = {}));
class MemberAssociation {
    constructor(a, b, associationType = AssociationType.Association, inerhited = false) {
        this.a = a;
        this.b = b;
        this.associationType = associationType;
        this.inerhited = inerhited;
    }
}
exports.MemberAssociation = MemberAssociation;
//# sourceMappingURL=model.js.map