"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.postProcessSvg = exports.emit = exports.Emitter = void 0;
const chalk_1 = __importDefault(require("chalk"));
const model_1 = require("./model");
class Emitter {
    constructor(template) {
        this.template = template;
    }
    emitSingleClass(cls) {
        return this.template.class(cls.name, cls.properties, cls.methods);
    }
    emitSingleInterface(int) {
        return this.template.interface(int.name, int.properties, int.methods);
    }
    emitSingleType(t) {
        return this.template.type(t.name, t.properties, t.methods);
    }
    emitSingleEnum(en) {
        return this.template.enum(en.name, en.items);
    }
    emitHeritageClauses(heritageClauses) {
        return heritageClauses.map((heritageClause) => {
            if (heritageClause.type === model_1.HeritageClauseType.Extends) {
                return this.template.extends(heritageClause.clause, heritageClause.className);
            }
            else {
                return this.template.implements(heritageClause.clause, heritageClause.className);
            }
        });
    }
    emitMemberAssociations(associations) {
        return associations ? associations.map(a => this.template.memberAssociation(a)) : [];
    }
}
exports.Emitter = Emitter;
function emit(declarations, emitter) {
    const entities = declarations.map(d => {
        console.log(chalk_1.default.yellow(d.fileName));
        const classes = d.classes.map((c) => emitter.emitSingleClass(c));
        const interfaces = d.interfaces.map((i) => emitter.emitSingleInterface(i));
        const enums = d.enums.map((i) => emitter.emitSingleEnum(i));
        const types = d.types.map((t) => emitter.emitSingleType(t));
        const heritageClauses = d.heritageClauses.map((clause) => emitter.emitHeritageClauses(clause));
        const memberAssociations = emitter.emitMemberAssociations(d.memberAssociations);
        return [...classes, ...interfaces, ...enums, ...types, ...heritageClauses.flat(), ...memberAssociations];
    }).flat();
    if (entities.length === 0) {
        const errorMsg = "Could not process any class / interface / enum / type";
        console.log(chalk_1.default.red(errorMsg));
        entities.push(`[${errorMsg}]`);
    }
    return entities.join("\n");
}
exports.emit = emit;
function xmlEncode(str) {
    return str
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&apos;');
}
/**
 * add type links to the svg
 * if a diagram path is given paths relative to the diagram will be generated for the links
 * @param svg
 * @param diagramPath
 * @param declarations
 * @returns
 */
function postProcessSvg(svg, diagramPath, declarations) {
    const classes = {};
    const interfaces = {};
    const enums = {};
    const types = {};
    declarations.map(d => {
        d.classes.forEach(cls => classes[xmlEncode(cls.name)] = cls);
        d.interfaces.forEach(i => interfaces[xmlEncode(i.name)] = i);
        d.enums.forEach(e => enums[xmlEncode(e.name)] = e);
        d.types.forEach(t => types[xmlEncode(t.name)] = t);
    });
    const rx = />(.*)</;
    const arOut = [];
    let regexResult;
    for (let line of svg.split('\n')) {
        line = line.trim();
        if (line.startsWith("<text") && (regexResult = rx.exec(line))) {
            let target = classes[regexResult[1]] || interfaces[regexResult[1]] || enums[regexResult[1]] || types[regexResult[1]];
            if (target) {
                const relPath = target.getRelativeFilePath(diagramPath);
                line = `<a id="${relPath}.${xmlEncode(target.name)}" xlink:href="${relPath}">${line}</a>`;
            }
        }
        arOut.push(line + '\n');
    }
    return arOut.join('');
}
exports.postProcessSvg = postProcessSvg;
//# sourceMappingURL=emitter.js.map