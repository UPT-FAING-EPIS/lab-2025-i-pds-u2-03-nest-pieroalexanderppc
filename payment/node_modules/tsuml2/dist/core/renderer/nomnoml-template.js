"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NomnomlTemplate = void 0;
const ts_morph_1 = require("ts-morph");
class NomnomlTemplate {
    constructor(settings) {
        this.settings = settings;
        this.composition = "+->";
    }
    implements(interf, implementation) {
        return `${this.plainClassOrInterface(interf)}<:--${this.plainClassOrInterface(implementation)}`;
    }
    extends(base, derived) {
        return `${this.plainClassOrInterface(base)}<:-${this.plainClassOrInterface(derived)}`;
    }
    plainClassOrInterface(name) { return `[${name}]`; }
    class(name, props, methods) {
        return `[${name}|${props.map(p => this.propertyTemplate(p)).join(";")}|${methods.map(m => this.methodTemplate(m)).join(";")}]`;
    }
    interface(name, props, methods) {
        return `[<interface>${name}|${props.map(p => this.propertyTemplate(p)).join(";")}|${methods.map(m => this.methodTemplate(m)).join(";")}]`;
    }
    type(name, props, methods) {
        return `[<type>${name}|${props.map(p => this.propertyTemplate(p)).join(";")}|${methods.map(m => this.methodTemplate(m)).join(";")}]`;
    }
    enum(name, enumItems) {
        return `[<enumeration>${name}|${enumItems.join(";")}]`;
    }
    memberAssociation(association) {
        return `${this.plainClassOrInterface(association.a.name)} ${association.a.multiplicity ?? ''} - ${association.b.multiplicity ?? ''} ${this.plainClassOrInterface(association.b.name)}`;
    }
    methodTemplate(method) {
        let retVal = method.name + "()";
        if (method.returnType && this.settings.propertyTypes) {
            retVal += ": " + escapeNomnoml(method.returnType);
        }
        retVal = this.modifierTemplate(method.modifierFlags) + retVal;
        return retVal;
    }
    propertyTemplate(property) {
        let retVal = escapeNomnoml(property.name);
        if (property.type && this.settings.propertyTypes) {
            if (property?.optional) {
                retVal += "?";
            }
            retVal += ": " + escapeNomnoml(property.type);
        }
        retVal = this.modifierTemplate(property.modifierFlags) + retVal;
        return retVal;
    }
    modifierTemplate(modifierFlags) {
        if (!this.settings.modifiers) {
            return "";
        }
        let retVal = "";
        // UML2: static member should be underlined --> Not supported by nomnoml 
        if (modifierFlags & ts_morph_1.ts.ModifierFlags.Static) {
            retVal = "static ";
        }
        if (modifierFlags & ts_morph_1.ts.ModifierFlags.Abstract) {
            retVal = "abstract ";
        }
        if (modifierFlags & ts_morph_1.ts.ModifierFlags.Private) {
            retVal = "-" + retVal;
        }
        else if (modifierFlags & ts_morph_1.ts.ModifierFlags.Protected) {
            retVal = "\\#" + retVal;
        }
        else {
            retVal = "+" + retVal;
        }
        return retVal;
    }
}
exports.NomnomlTemplate = NomnomlTemplate;
;
// utility functions
function escapeNomnoml(str) {
    return str.replace(/[|\][\#]/g, '\\$&');
}
//# sourceMappingURL=nomnoml-template.js.map