"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MermaidTemplate = void 0;
const ts_morph_1 = require("ts-morph");
class MermaidTemplate {
    constructor(settings) {
        this.settings = settings;
        this.composition = "+->";
    }
    implements(interf, implementation) {
        return (`${this.plainClassOrInterface(interf)}<|..${this.plainClassOrInterface(implementation)}`);
    }
    extends(base, derived) {
        return `${this.plainClassOrInterface(base)}<|--${this.plainClassOrInterface(derived)}`;
    }
    plainClassOrInterface(name) { return escapeMermaid(name); }
    class(name, props, methods) {
        return `class ${escapeMermaid(name)}{
            ${props.map(p => this.propertyTemplate(p)).join("\n")}
            ${methods.map(m => this.methodTemplate(m)).join("\n")}
        }`;
    }
    interface(name, props, methods) {
        return `class ${escapeMermaid(name)} {
            <<interface>>
            ${props.map(p => this.propertyTemplate(p)).join("\n")}
            ${methods.map(m => this.methodTemplate(m)).join("\n")}
        }`;
    }
    ;
    type(name, props, methods) {
        return `class ${escapeMermaid(name)} {
            <<type>>
            ${props.map(p => this.propertyTemplate(p)).join("\n")}
            ${methods.map(m => this.methodTemplate(m)).join("\n")}
        }`;
    }
    enum(name, enumItems) {
        return `class ${escapeMermaid(name)} {
        <<enumeration>>
        ${enumItems.join("\n")}
      }`;
    }
    memberAssociation(association) {
        const multiplicityA = association.a.multiplicity ? `"${association.a.multiplicity}"` : "";
        const multiplicityB = association.b.multiplicity ? `"${association.b.multiplicity}"` : "";
        return `${this.plainClassOrInterface(association.a.name)} ${multiplicityA} -- ${multiplicityB} ${this.plainClassOrInterface(association.b.name)}`;
    }
    propertyTemplate(property) {
        let retVal = property.name;
        if (property.type && this.settings.propertyTypes) {
            if (property?.optional) {
                retVal += "?";
            }
            retVal += ": " + escapeMermaid(property.type);
        }
        return this.applyModifiers(property.modifierFlags, retVal);
    }
    methodTemplate(method) {
        let retVal = method.name + "()";
        if (method.returnType && this.settings.propertyTypes) {
            retVal += " " + escapeMermaid(method.returnType);
        }
        return this.applyModifiers(method.modifierFlags, retVal);
    }
    applyModifiers(modifierFlags, method) {
        if (!this.settings.modifiers) {
            return method;
        }
        let retVal = "";
        if (modifierFlags & ts_morph_1.ts.ModifierFlags.Private) {
            retVal = "-";
        }
        else if (modifierFlags & ts_morph_1.ts.ModifierFlags.Protected) {
            retVal = "#";
        }
        else {
            retVal = "+";
        }
        retVal += method;
        // UML2: static member will be underlined 
        if (modifierFlags & ts_morph_1.ts.ModifierFlags.Static) {
            retVal = retVal + "$";
        }
        // abstract member will be italic
        if (modifierFlags & ts_morph_1.ts.ModifierFlags.Abstract) {
            retVal = retVal + "*";
        }
        return retVal;
    }
}
exports.MermaidTemplate = MermaidTemplate;
// utility functions
function escapeMermaid(str) {
    return str.replace(/[<>]/g, '~').replace('{', "#123;").replace('}', "#125;");
}
//# sourceMappingURL=mermaid-template.js.map