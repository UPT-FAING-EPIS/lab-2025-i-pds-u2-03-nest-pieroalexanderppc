"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseAssociations = void 0;
const model_1 = require("../model");
function parseAssociations(declarations) {
    const associationMap = new Map();
    const typeMap = createTypeMap(declarations);
    declarations.forEach(decl => {
        const associations = [
            decl.classes.map(clazz => parseAssociationOfAnyType(clazz, associationMap, typeMap)),
            decl.interfaces.map(inter => parseAssociationOfAnyType(inter, associationMap, typeMap)),
            decl.types.map(t => parseAssociationOfAnyType(t, associationMap, typeMap)),
        ];
        decl.memberAssociations = associations.flat(2);
    });
    processAssociationInheritance(associationMap, typeMap);
    deduplicateAssociations(declarations);
}
exports.parseAssociations = parseAssociations;
function createTypeMap(declarations) {
    const typeMap = new Map();
    declarations.forEach(decl => {
        decl.classes.forEach(clazz => typeMap.set(clazz.id, clazz));
        decl.interfaces.forEach(inter => typeMap.set(inter.id, inter));
        decl.types.forEach(t => typeMap.set(t.id, t));
        decl.enums.forEach(e => typeMap.set(e.id, e));
    });
    return typeMap;
}
function parseAssociationOfAnyType(t, associationMap, typeMap) {
    const associations = [];
    t.properties.filter(prop => prop.typeIds.length > 0).forEach(prop => {
        prop.typeIds.forEach(id => {
            const assId = `${t.id}_${id}`;
            const reverseId = `${id}_${t.id}`;
            let ass = associationMap.get(reverseId);
            if (!ass) {
                const propType = typeMap.get(id);
                if (!propType) {
                    return;
                }
                ass = new model_1.MemberAssociation({ typeId: t.id, name: t.name }, { typeId: id, name: propType.name, multiplicity: getMultiplicityOfProp(prop) });
                associationMap.set(assId, ass);
                associations.push(ass);
            }
            else {
                createReverseAssociation(ass, prop);
            }
        });
    });
    return associations;
}
function createReverseAssociation(association, prop) {
    association.a.multiplicity = getMultiplicityOfProp(prop);
}
function getMultiplicityOfProp(prop) {
    if (prop.type && prop.type.includes("[")) {
        return '0..*';
    }
    return undefined;
}
/**
 * remove associations from sub types / classes / interfaces
 * if an association to the same member is already present in the base type / class / interface
 */
function processAssociationInheritance(associationMap, typeMap) {
    associationMap.forEach((association, id) => {
        if (checkInheritedAssociation(association.a.typeId, association.b.typeId, associationMap, typeMap)) {
            associationMap.delete(id);
        }
    });
}
function checkInheritedAssociation(srcTypeId, associatedTypeId, associationMap, typeMap) {
    let inherited = false;
    const type = typeMap.get(srcTypeId);
    const heritageClauses = type.heritageClauses;
    for (const clause of heritageClauses) {
        const base = typeMap.get(clause.clauseTypeId);
        if (!base) {
            continue;
        }
        inherited = associationMap.has(`${base.id}_${associatedTypeId}`);
        inherited = checkInheritedAssociation(base.id, associatedTypeId, associationMap, typeMap) || inherited;
        if (inherited) {
            associationMap.get(`${srcTypeId}_${associatedTypeId}`).inerhited = true;
        }
    }
    return inherited;
}
function deduplicateAssociations(declarations) {
    declarations.forEach(decl => {
        decl.memberAssociations = decl.memberAssociations?.filter(ass => !ass.inerhited);
    });
}
//# sourceMappingURL=associations.js.map